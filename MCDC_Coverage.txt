MC/DC（Modified Condition/Decision Coverage）は、テストカバレッジの一種で、論理的な決定（Decision Coverage）とその決定内の個々の条件（Condition）がテストされることを保証するものです。

Modified Conditionの概念
「Modified Condition」は、論理的な決定における個々の条件が、その他の条件が固定された状態で変更されたときに、決定結果にどのような影響を与えるかをテストします。このアプローチでは、各条件が他の条件と独立して、決定に与える影響を特定し、分析します。

Decision Coverageの概念
• 全ての決定ポイントをカバー: プログラムの各決定ポイント（if文、switch文、ループなど）がテストされ、それぞれのポイントで可能な全ての結果（真と偽）が発生するようにします。
• 結果の確認: 決定ポイントの各可能な結果が、それに応じた挙動を引き起こすことを確認します。

論理回路ブロック

Switchブロックの条件式に基づくテストケース
1. 条件信号が0でない場合:
	• テストケース 1: 条件信号 = 任意の非ゼロ値 (例えば1), 入力1 = X, 入力2 = Y → 出力 = X
	• このテストは条件信号が0以外の値を持つ場合、Switchブロックが入力1を選択することを確認します。
2. 条件信号が0の場合:
	• テストケース 2: 条件信号 = 0, 入力1 = X, 入力2 = Y → 出力 = Y
	• このテストは条件信号が0のときにSwitchブロックが入力2を選択することを確認します。

Multiport Switchブロックの基本
Multiport Switchブロックは、制御入力（整数値または列挙型）に基づいて、複数のデータ入力ソースからの選択を行います。例えば、制御入力が3つの値（1, 2, 3）を取り、それに応じて3つの異なるデータ入力ソース（入力1, 入力2, 入力3）から選択を行う設定が考えられます。
MC/DCを満たすテストケースの設計
制御入力が3つの値（1, 2, 3）を取る場合、以下のようなテストケースが必要です：
1. 制御入力が1の場合:
	• テストケース 1: 制御入力 = 1, 入力1 = A, 入力2 = B, 入力3 = C → 出力 = A
2. 制御入力が2の場合:
	• テストケース 2: 制御入力 = 2, 入力1 = A, 入力2 = B, 入力3 = C → 出力 = B
3. 制御入力が3の場合:
	• テストケース 3: 制御入力 = 3, 入力1 = A, 入力2 = B, 入力3 = C → 出力 = C

Switch Caseブロックのテストケース設計
Switch Caseブロックで「case 1」、「case 2」、「case 3」という3つのケースを考慮する場合、MC/DC 100%を満たすためには、次のようなテストケースが考えられます。
1. 「case 1」が選択される場合:
	• テストケース 1: 入力 = 1 → 「case 1」が実行される
2. 「case 2」が選択される場合:
	• テストケース 2: 入力 = 2 → 「case 2」が実行される
3. 「case 3」が選択される場合:
	• テストケース 3: 入力 = 3 → 「case 3」が実行される
4. Default ケース（該当しない場合）:
	• テストケース 4: 入力 = それ以外の値（例: 4） → Defaultケースが実行される

Logical Operatorブロックの基本
Logical Operatorブロックは、複数の入力に対して論理演算（AND, OR, NOTなど）を実行します。例として、2つの入力に対するAND演算を考えます。
MC/DCを満たすテストケースの設計
例：Logical Operatorブロックで「AND」演算を実行する場合
1. 条件Aの影響をテスト:
	• テストケース 1: A = 真, B = 真 → 出力 = 真
	• テストケース 2: A = 偽, B = 真 → 出力 = 偽
	• テストケース 3: A = 真, B = 偽 → 出力 = 偽
	• テストケース 4: A = 偽, B = 偽 → 出力 = 偽
	
2. 条件Bの影響をテスト:
	• テストケース 1: A = 真, B = 真 → 出力 = 真
	• テストケース 2: A = 真, B = 偽 → 出力 = 偽
	• テストケース 3: A = 偽, B = 真 → 出力 = 偽
	• テストケース 4: A = 偽, B = 偽 → 出力 = 偽

例：Logical Operatorブロックで「OR」演算を実行する場合
1. 条件Aの影響をテスト:
	• テストケース 1: A = 真, B = 真 → 出力 = 真
	• テストケース 2: A = 偽, B = 真 → 出力 = 真
	• テストケース 3: A = 真, B = 偽 → 出力 = 真
	• テストケース 4: A = 偽, B = 偽 → 出力 = 偽
	
2. 条件Bの影響をテスト:
	• テストケース 1: A = 真, B = 真 → 出力 = 真
	• テストケース 2: A = 真, B = 偽 → 出力 = 真
	• テストケース 3: A = 偽, B = 真 → 出力 = 真
	• テストケース 4: A = 偽, B = 偽 → 出力 = 偽

例：Logical Operatorブロックで「NOT」演算を実行する場合
    NOT演算は、単一の入力の論理否定を行います。
    • テストケース 1: A = 真 → 出力 = 偽
    • テストケース 2: A = 偽 → 出力 = 真

Relational Operatorブロックの基本
Relational Operatorブロックは、2つの入力に対して関係演算を行います。例として、入力Aと入力Bに対する「より大きい（>）」演算を考えます。
MC/DCを満たすテストケースの設計
例：Relational Operatorブロックで「A > B」の演算を実行する場合
1. AがBより大きい場合:
	• テストケース 1: A = 5, B = 3 → 出力 = 真（AはBより大きい）
2. AがBより小さい場合:
	• テストケース 2: A = 2, B = 4 → 出力 = 偽（AはBより小さい）
3. AとBが等しい場合:
	• テストケース 3: A = 3, B = 3 → 出力 = 偽（AとBは等しいため、AはBより大きくない）

理論回路ブロック

1次元Lookup Tableブロックのテストケース
1次元Lookup Tableブロックは、1つの入力に対して特定の出力値を提供します。テストケースは以下のように設計されます：
1. テーブルの内部点:
	• テストケース 1: 入力がテーブルの内部点にある場合（例: 入力 = 中間値） → 出力は補間された値
2. テーブルの端点:
	• テストケース 2: 入力がテーブルの端点にある場合（例: 入力 = 最小値または最大値） → 出力は端点の値
3. テーブルの範囲外:
	• テストケース 3: 入力がテーブルの範囲外にある場合（例: 入力 = 最大値より大きい） → 出力は外挿された値

2次元Lookup Tableブロックのテストケース
2次元Lookup Tableブロックは、2つの入力に対して特定の出力値を提供します。テストケースは以下のように設計されます：
1. テーブルの内部点:
	• テストケース 1: 両入力がテーブルの内部点にある場合（例: 入力1 = 中間値、入力2 = 中間値） → 出力は補間された値
2. テーブルの端点:
	• テストケース 2: 両入力がテーブルの端点にある場合（例: 入力1 = 最小値、入力2 = 最大値） → 出力は端点の値
3. テーブルの範囲外:
	• テストケース 3: 一方または両方の入力がテーブルの範囲外にある場合（例: 入力1 = 最大値より大きい、入力2 = 最小値より小さい） → 出力は外挿された値
	
MinMaxブロックのテストケース設計
例として、MinMaxブロックが最大値を選択する設定を考えます。入力が A、B、C の3つあるとします。
1. 入力Aが最大値である場合:
    • テストケース 1: A = 5, B = 3, C = 4 → 出力 = 5
    • Aを最大値にすることで、Aが選択されることを確認します。
2. 入力Bが最大値である場合:
    • テストケース 2: A = 4, B = 6, C = 2 → 出力 = 6
    • Bを最大値にすることで、Bが選択されることを確認します。
3. 入力Cが最大値である場合:
    • テストケース 3: A = 3, B = 1, C = 7 → 出力 = 7
    • Cを最大値にすることで、Cが選択されることを確認します。

Saturationブロックのテストケース設計
例えば、Saturationブロックが下限値を0、上限値を10とする設定の場合、以下のようなテストケースが考えられます：
1. 上限値を超える入力:
    • テストケース 1: 入力 = 12（上限値より大きい値） → 出力 = 10（上限値に制限）
2. 上限値内の入力:
    • テストケース 2: 入力 = 8（上限値より小さいが下限値より大きい値） → 出力 = 8（入力値がそのまま出力）
3. 下限値を下回る入力:
    • テストケース 3: 入力 = -2（下限値より小さい値） → 出力 = 0（下限値に制限）
4. 下限値内の入力:
    • テストケース 4: 入力 = 3（下限値より大きいが上限値より小さい値） → 出力 = 3（入力値がそのまま出力）
